"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/fluid-shader.tsx":
/*!*****************************************!*\
  !*** ./src/components/fluid-shader.tsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FluidShader)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction FluidShader() {\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const lastRenderRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const frameRate = 10;\n    const isMobile =  true ? /Mobi|Android/i.test(navigator.userAgent) : 0;\n    const fragmentShaderSource = \"#version 300 es\\nprecision mediump float;\\nout vec4 O;\\nuniform float time;\\nuniform vec2 resolution;\\n#define FC gl_FragCoord.xy\\n#define R resolution\\n#define T (time+660.)\\n#define S smoothstep\\n#define N normalize\\nfloat rnd(vec2 p) {\\n    p=fract(p*vec2(12.9898,78.233));\\n    p+=dot(p,p+34.56);\\n    return fract(p.x*p.y);\\n}\\nfloat noise(vec2 p) {\\n    vec2 i=floor(p), f=fract(p), u=f*f*(3.-2.*f), k=vec2(1,0);\\n    float a=rnd(i), b=rnd(i+k), c=rnd(i+k.yx), d=rnd(i+1.);\\n    return mix(mix(a,b,u.x),mix(c,d,u.x),u.y);\\n}\\nfloat fbm(vec2 p) {\\n    float t=.0, a=1., h=.0; mat2 m=mat2(1.,-1.2,.2,1.2);\\n    for (float i=.0; i<4.; i++) {\\n        t+=a*noise(p);\\n        p*=2.*m;\\n        a*=.5;\\n        h+=a;\\n    }\\n    return t/h;\\n}\\nvoid main() {\\n    vec2 uv=(FC-.5*R)/R.y, k=vec2(0,T*.015); \\n    vec3 col=vec3(1);\\n    uv.x+=.25;\\n    uv*=vec2(2,1);\\n    float n=fbm(uv*.28+vec2(-T*.01,0));\\n    n=noise(uv*3.+n*2.);\\n    col.r-=fbm(uv+k+n);\\n    col.g-=fbm(uv*1.003+k+n+.003);\\n    col.b-=fbm(uv*1.006+k+n+.006);\\n    col=mix(col,vec3(1),dot(col,vec3(.21,.71,.07)));\\n    col=mix(vec3(.08),col,min(time*.1,1.));\\n    col=clamp(col,.08,1.);\\n    col.r *= 0.2;\\n    col.g *= 1.0;\\n    col.b *= 0.9;\\n    O=vec4(col,1);\\n}\";\n    const setupWebGL = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"FluidShader.useCallback[setupWebGL]\": ()=>{\n            const canvas = canvasRef.current;\n            if (!canvas) return null;\n            const dpr = isMobile ? 1 : Math.min(1.5, window.devicePixelRatio);\n            const { innerWidth: width, innerHeight: height } = window;\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n            try {\n                return canvas.getContext('webgl2', {\n                    antialias: false,\n                    powerPreference: isMobile ? 'low-power' : 'high-performance'\n                });\n            } catch (e) {\n                return null;\n            }\n        }\n    }[\"FluidShader.useCallback[setupWebGL]\"], [\n        isMobile\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"FluidShader.useEffect\": ()=>{\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            const gl = setupWebGL();\n            if (!gl) return;\n            let renderer = new Renderer(canvas, gl);\n            let animationFrameId;\n            const handleResize = {\n                \"FluidShader.useEffect.handleResize\": ()=>{\n                    const dpr = isMobile ? 1 : Math.min(1.5, window.devicePixelRatio);\n                    const { innerWidth: width, innerHeight: height } = window;\n                    canvas.width = width * dpr;\n                    canvas.height = height * dpr;\n                    renderer === null || renderer === void 0 ? void 0 : renderer.updateScale(dpr);\n                }\n            }[\"FluidShader.useEffect.handleResize\"];\n            const debouncedResize = debounce(handleResize, 100);\n            window.addEventListener('resize', debouncedResize);\n            const render = {\n                \"FluidShader.useEffect.render\": (now)=>{\n                    if (now - lastRenderRef.current >= 1000 / frameRate) {\n                        renderer === null || renderer === void 0 ? void 0 : renderer.render(now);\n                        lastRenderRef.current = now;\n                    }\n                    animationFrameId = requestAnimationFrame(render);\n                }\n            }[\"FluidShader.useEffect.render\"];\n            renderer.init(fragmentShaderSource);\n            render(0);\n            return ({\n                \"FluidShader.useEffect\": ()=>{\n                    window.removeEventListener('resize', debouncedResize);\n                    cancelAnimationFrame(animationFrameId);\n                    renderer === null || renderer === void 0 ? void 0 : renderer.cleanup();\n                }\n            })[\"FluidShader.useEffect\"];\n        }\n    }[\"FluidShader.useEffect\"], [\n        fragmentShaderSource,\n        isMobile,\n        setupWebGL\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        className: \"fixed inset-0 w-full h-full block\"\n    }, void 0, false, {\n        fileName: \"/Users/nitishkumar/Desktop/verbose-pancake/src/components/fluid-shader.tsx\",\n        lineNumber: 119,\n        columnNumber: 5\n    }, this);\n}\n_s(FluidShader, \"rN7eYWVNVHgJ/Fd8evCyaHGm+kw=\");\n_c = FluidShader;\nclass Renderer {\n    init(shaderSource) {\n        const vertexShader = this.compileShader(this.gl.VERTEX_SHADER, \"#version 300 es\\nprecision lowp float;\\nin vec2 position;\\nvoid main() { gl_Position = vec4(position, 0.0, 1.0); }\");\n        const fragmentShader = this.compileShader(this.gl.FRAGMENT_SHADER, shaderSource);\n        if (!vertexShader || !fragmentShader) return;\n        this.program = this.gl.createProgram();\n        if (!this.program) return;\n        this.gl.attachShader(this.program, vertexShader);\n        this.gl.attachShader(this.program, fragmentShader);\n        this.gl.linkProgram(this.program);\n        if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {\n            console.error(this.gl.getProgramInfoLog(this.program));\n            return;\n        }\n        this.buffer = this.gl.createBuffer();\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([\n            -1,\n            1,\n            -1,\n            -1,\n            1,\n            1,\n            1,\n            -1\n        ]), this.gl.STATIC_DRAW);\n        const positionLocation = this.gl.getAttribLocation(this.program, 'position');\n        this.timeUniform = this.gl.getUniformLocation(this.program, 'time');\n        this.resolutionUniform = this.gl.getUniformLocation(this.program, 'resolution');\n        this.gl.enableVertexAttribArray(positionLocation);\n        this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 0, 0);\n    }\n    compileShader(type, source) {\n        const shader = this.gl.createShader(type);\n        if (!shader) return null;\n        this.gl.shaderSource(shader, source);\n        this.gl.compileShader(shader);\n        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\n            console.error(this.gl.getShaderInfoLog(shader));\n            return null;\n        }\n        return shader;\n    }\n    updateScale(scale) {\n        this.scale = scale;\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n    }\n    render(time) {\n        if (!this.program || !this.resolutionUniform || !this.timeUniform) return;\n        this.gl.useProgram(this.program);\n        this.gl.uniform1f(this.timeUniform, time * 0.001);\n        this.gl.uniform2f(this.resolutionUniform, this.canvas.width, this.canvas.height);\n        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);\n    }\n    cleanup() {\n        this.gl.deleteProgram(this.program);\n        this.gl.deleteBuffer(this.buffer);\n    }\n    constructor(canvas, gl){\n        this.program = null;\n        this.buffer = null;\n        this.timeUniform = null;\n        this.resolutionUniform = null;\n        this.canvas = canvas;\n        this.gl = gl;\n        this.scale = 1;\n        this.gl.getExtension('EXT_color_buffer_float');\n    }\n}\nfunction debounce(fn, delay) {\n    let timeout;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        clearTimeout(timeout);\n        timeout = setTimeout(()=>fn(...args), delay);\n    };\n}\nvar _c;\n$RefreshReg$(_c, \"FluidShader\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2ZsdWlkLXNoYWRlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRXNEO0FBRXZDLFNBQVNHOztJQUN0QixNQUFNQyxZQUFZSCw2Q0FBTUEsQ0FBb0I7SUFDNUMsTUFBTUksZ0JBQWdCSiw2Q0FBTUEsQ0FBQztJQUM3QixNQUFNSyxZQUFZO0lBQ2xCLE1BQU1DLFdBQVcsS0FBNkIsR0FBRyxnQkFBZ0JDLElBQUksQ0FBQ0MsVUFBVUMsU0FBUyxJQUFJLENBQUs7SUFFbEcsTUFBTUMsdUJBQXdCO0lBaUQ5QixNQUFNQyxhQUFhVixrREFBV0E7K0NBQUM7WUFDN0IsTUFBTVcsU0FBU1QsVUFBVVUsT0FBTztZQUNoQyxJQUFJLENBQUNELFFBQVEsT0FBTztZQUVwQixNQUFNRSxNQUFNUixXQUFXLElBQUlTLEtBQUtDLEdBQUcsQ0FBQyxLQUFLQyxPQUFPQyxnQkFBZ0I7WUFDaEUsTUFBTSxFQUFFQyxZQUFZQyxLQUFLLEVBQUVDLGFBQWFDLE1BQU0sRUFBRSxHQUFHTDtZQUNuREwsT0FBT1EsS0FBSyxHQUFHQSxRQUFRTjtZQUN2QkYsT0FBT1UsTUFBTSxHQUFHQSxTQUFTUjtZQUV6QixJQUFJO2dCQUNGLE9BQU9GLE9BQU9XLFVBQVUsQ0FBQyxVQUFVO29CQUNqQ0MsV0FBVztvQkFDWEMsaUJBQWlCbkIsV0FBVyxjQUFjO2dCQUM1QztZQUNGLEVBQUUsT0FBT29CLEdBQUc7Z0JBQ1YsT0FBTztZQUNUO1FBQ0Y7OENBQUc7UUFBQ3BCO0tBQVM7SUFFYlAsZ0RBQVNBO2lDQUFDO1lBQ1IsTUFBTWEsU0FBU1QsVUFBVVUsT0FBTztZQUNoQyxJQUFJLENBQUNELFFBQVE7WUFFYixNQUFNZSxLQUFLaEI7WUFDWCxJQUFJLENBQUNnQixJQUFJO1lBRVQsSUFBSUMsV0FBNEIsSUFBSUMsU0FBU2pCLFFBQVFlO1lBQ3JELElBQUlHO1lBRUosTUFBTUM7c0RBQWU7b0JBQ25CLE1BQU1qQixNQUFNUixXQUFXLElBQUlTLEtBQUtDLEdBQUcsQ0FBQyxLQUFLQyxPQUFPQyxnQkFBZ0I7b0JBQ2hFLE1BQU0sRUFBRUMsWUFBWUMsS0FBSyxFQUFFQyxhQUFhQyxNQUFNLEVBQUUsR0FBR0w7b0JBQ25ETCxPQUFPUSxLQUFLLEdBQUdBLFFBQVFOO29CQUN2QkYsT0FBT1UsTUFBTSxHQUFHQSxTQUFTUjtvQkFDekJjLHFCQUFBQSwrQkFBQUEsU0FBVUksV0FBVyxDQUFDbEI7Z0JBQ3hCOztZQUVBLE1BQU1tQixrQkFBa0JDLFNBQVNILGNBQWM7WUFDL0NkLE9BQU9rQixnQkFBZ0IsQ0FBQyxVQUFVRjtZQUVsQyxNQUFNRztnREFBUyxDQUFDQztvQkFDZCxJQUFJQSxNQUFNakMsY0FBY1MsT0FBTyxJQUFJLE9BQU9SLFdBQVc7d0JBQ25EdUIscUJBQUFBLCtCQUFBQSxTQUFVUSxNQUFNLENBQUNDO3dCQUNqQmpDLGNBQWNTLE9BQU8sR0FBR3dCO29CQUMxQjtvQkFDQVAsbUJBQW1CUSxzQkFBc0JGO2dCQUMzQzs7WUFFQVIsU0FBU1csSUFBSSxDQUFDN0I7WUFDZDBCLE9BQU87WUFFUDt5Q0FBTztvQkFDTG5CLE9BQU91QixtQkFBbUIsQ0FBQyxVQUFVUDtvQkFDckNRLHFCQUFxQlg7b0JBQ3JCRixxQkFBQUEsK0JBQUFBLFNBQVVjLE9BQU87Z0JBQ25COztRQUNGO2dDQUFHO1FBQUNoQztRQUFzQko7UUFBVUs7S0FBVztJQUUvQyxxQkFDRSw4REFBQ0M7UUFBTytCLEtBQUt4QztRQUFXeUMsV0FBVTs7Ozs7O0FBRXRDO0dBcEh3QjFDO0tBQUFBO0FBc0h4QixNQUFNMkI7SUFnQkpVLEtBQUtNLFlBQW9CLEVBQUU7UUFDekIsTUFBTUMsZUFBZSxJQUFJLENBQUNDLGFBQWEsQ0FBQyxJQUFJLENBQUNwQixFQUFFLENBQUNxQixhQUFhLEVBQzFEO1FBTUgsTUFBTUMsaUJBQWlCLElBQUksQ0FBQ0YsYUFBYSxDQUFDLElBQUksQ0FBQ3BCLEVBQUUsQ0FBQ3VCLGVBQWUsRUFBRUw7UUFFbkUsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQ0csZ0JBQWdCO1FBRXRDLElBQUksQ0FBQ0UsT0FBTyxHQUFHLElBQUksQ0FBQ3hCLEVBQUUsQ0FBQ3lCLGFBQWE7UUFDcEMsSUFBSSxDQUFDLElBQUksQ0FBQ0QsT0FBTyxFQUFFO1FBRW5CLElBQUksQ0FBQ3hCLEVBQUUsQ0FBQzBCLFlBQVksQ0FBQyxJQUFJLENBQUNGLE9BQU8sRUFBRUw7UUFDbkMsSUFBSSxDQUFDbkIsRUFBRSxDQUFDMEIsWUFBWSxDQUFDLElBQUksQ0FBQ0YsT0FBTyxFQUFFRjtRQUNuQyxJQUFJLENBQUN0QixFQUFFLENBQUMyQixXQUFXLENBQUMsSUFBSSxDQUFDSCxPQUFPO1FBRWhDLElBQUksQ0FBQyxJQUFJLENBQUN4QixFQUFFLENBQUM0QixtQkFBbUIsQ0FBQyxJQUFJLENBQUNKLE9BQU8sRUFBRSxJQUFJLENBQUN4QixFQUFFLENBQUM2QixXQUFXLEdBQUc7WUFDbkVDLFFBQVFDLEtBQUssQ0FBQyxJQUFJLENBQUMvQixFQUFFLENBQUNnQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUNSLE9BQU87WUFDcEQ7UUFDRjtRQUVBLElBQUksQ0FBQ1MsTUFBTSxHQUFHLElBQUksQ0FBQ2pDLEVBQUUsQ0FBQ2tDLFlBQVk7UUFDbEMsSUFBSSxDQUFDbEMsRUFBRSxDQUFDbUMsVUFBVSxDQUFDLElBQUksQ0FBQ25DLEVBQUUsQ0FBQ29DLFlBQVksRUFBRSxJQUFJLENBQUNILE1BQU07UUFDcEQsSUFBSSxDQUFDakMsRUFBRSxDQUFDcUMsVUFBVSxDQUFDLElBQUksQ0FBQ3JDLEVBQUUsQ0FBQ29DLFlBQVksRUFBRSxJQUFJRSxhQUFhO1lBQUMsQ0FBQztZQUFHO1lBQUcsQ0FBQztZQUFHLENBQUM7WUFBRztZQUFHO1lBQUc7WUFBRyxDQUFDO1NBQUUsR0FBRyxJQUFJLENBQUN0QyxFQUFFLENBQUN1QyxXQUFXO1FBRTVHLE1BQU1DLG1CQUFtQixJQUFJLENBQUN4QyxFQUFFLENBQUN5QyxpQkFBaUIsQ0FBQyxJQUFJLENBQUNqQixPQUFPLEVBQUU7UUFDakUsSUFBSSxDQUFDa0IsV0FBVyxHQUFHLElBQUksQ0FBQzFDLEVBQUUsQ0FBQzJDLGtCQUFrQixDQUFDLElBQUksQ0FBQ25CLE9BQU8sRUFBRTtRQUM1RCxJQUFJLENBQUNvQixpQkFBaUIsR0FBRyxJQUFJLENBQUM1QyxFQUFFLENBQUMyQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUNuQixPQUFPLEVBQUU7UUFFbEUsSUFBSSxDQUFDeEIsRUFBRSxDQUFDNkMsdUJBQXVCLENBQUNMO1FBQ2hDLElBQUksQ0FBQ3hDLEVBQUUsQ0FBQzhDLG1CQUFtQixDQUFDTixrQkFBa0IsR0FBRyxJQUFJLENBQUN4QyxFQUFFLENBQUMrQyxLQUFLLEVBQUUsT0FBTyxHQUFHO0lBQzVFO0lBRVEzQixjQUFjNEIsSUFBWSxFQUFFQyxNQUFjLEVBQXNCO1FBQ3RFLE1BQU1DLFNBQVMsSUFBSSxDQUFDbEQsRUFBRSxDQUFDbUQsWUFBWSxDQUFDSDtRQUNwQyxJQUFJLENBQUNFLFFBQVEsT0FBTztRQUVwQixJQUFJLENBQUNsRCxFQUFFLENBQUNrQixZQUFZLENBQUNnQyxRQUFRRDtRQUM3QixJQUFJLENBQUNqRCxFQUFFLENBQUNvQixhQUFhLENBQUM4QjtRQUV0QixJQUFJLENBQUMsSUFBSSxDQUFDbEQsRUFBRSxDQUFDb0Qsa0JBQWtCLENBQUNGLFFBQVEsSUFBSSxDQUFDbEQsRUFBRSxDQUFDcUQsY0FBYyxHQUFHO1lBQy9EdkIsUUFBUUMsS0FBSyxDQUFDLElBQUksQ0FBQy9CLEVBQUUsQ0FBQ3NELGdCQUFnQixDQUFDSjtZQUN2QyxPQUFPO1FBQ1Q7UUFDQSxPQUFPQTtJQUNUO0lBRUE3QyxZQUFZa0QsS0FBYSxFQUFFO1FBQ3pCLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ3ZELEVBQUUsQ0FBQ3dELFFBQVEsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDdkUsTUFBTSxDQUFDUSxLQUFLLEVBQUUsSUFBSSxDQUFDUixNQUFNLENBQUNVLE1BQU07SUFDOUQ7SUFFQWMsT0FBT2dELElBQVksRUFBRTtRQUNuQixJQUFJLENBQUMsSUFBSSxDQUFDakMsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDb0IsaUJBQWlCLElBQUksQ0FBQyxJQUFJLENBQUNGLFdBQVcsRUFBRTtRQUVuRSxJQUFJLENBQUMxQyxFQUFFLENBQUMwRCxVQUFVLENBQUMsSUFBSSxDQUFDbEMsT0FBTztRQUMvQixJQUFJLENBQUN4QixFQUFFLENBQUMyRCxTQUFTLENBQUMsSUFBSSxDQUFDakIsV0FBVyxFQUFFZSxPQUFPO1FBQzNDLElBQUksQ0FBQ3pELEVBQUUsQ0FBQzRELFNBQVMsQ0FBQyxJQUFJLENBQUNoQixpQkFBaUIsRUFBRSxJQUFJLENBQUMzRCxNQUFNLENBQUNRLEtBQUssRUFBRSxJQUFJLENBQUNSLE1BQU0sQ0FBQ1UsTUFBTTtRQUMvRSxJQUFJLENBQUNLLEVBQUUsQ0FBQzZELFVBQVUsQ0FBQyxJQUFJLENBQUM3RCxFQUFFLENBQUM4RCxjQUFjLEVBQUUsR0FBRztJQUNoRDtJQUVBL0MsVUFBVTtRQUNSLElBQUksQ0FBQ2YsRUFBRSxDQUFDK0QsYUFBYSxDQUFDLElBQUksQ0FBQ3ZDLE9BQU87UUFDbEMsSUFBSSxDQUFDeEIsRUFBRSxDQUFDZ0UsWUFBWSxDQUFDLElBQUksQ0FBQy9CLE1BQU07SUFDbEM7SUExRUFnQyxZQUFZaEYsTUFBeUIsRUFBRWUsRUFBMEIsQ0FBRTthQU4zRHdCLFVBQStCO2FBQy9CUyxTQUE2QjthQUU3QlMsY0FBMkM7YUFDM0NFLG9CQUFpRDtRQUd2RCxJQUFJLENBQUMzRCxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDZSxFQUFFLEdBQUdBO1FBQ1YsSUFBSSxDQUFDdUQsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDdkQsRUFBRSxDQUFDa0UsWUFBWSxDQUFDO0lBQ3ZCO0FBc0VGO0FBRUEsU0FBUzNELFNBQTZDNEQsRUFBSyxFQUFFQyxLQUFhO0lBQ3hFLElBQUlDO0lBQ0osT0FBTzt5Q0FBSUM7WUFBQUE7O1FBQ1RDLGFBQWFGO1FBQ2JBLFVBQVVHLFdBQVcsSUFBTUwsTUFBTUcsT0FBT0Y7SUFDMUM7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL25pdGlzaGt1bWFyL0Rlc2t0b3AvdmVyYm9zZS1wYW5jYWtlL3NyYy9jb21wb25lbnRzL2ZsdWlkLXNoYWRlci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInJlYWN0XCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmx1aWRTaGFkZXIoKSB7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbClcbiAgY29uc3QgbGFzdFJlbmRlclJlZiA9IHVzZVJlZigwKVxuICBjb25zdCBmcmFtZVJhdGUgPSAxMFxuICBjb25zdCBpc01vYmlsZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gL01vYml8QW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgOiBmYWxzZVxuXG4gIGNvbnN0IGZyYWdtZW50U2hhZGVyU291cmNlID0gYCN2ZXJzaW9uIDMwMCBlc1xucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5vdXQgdmVjNCBPO1xudW5pZm9ybSBmbG9hdCB0aW1lO1xudW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XG4jZGVmaW5lIEZDIGdsX0ZyYWdDb29yZC54eVxuI2RlZmluZSBSIHJlc29sdXRpb25cbiNkZWZpbmUgVCAodGltZSs2NjAuKVxuI2RlZmluZSBTIHNtb290aHN0ZXBcbiNkZWZpbmUgTiBub3JtYWxpemVcbmZsb2F0IHJuZCh2ZWMyIHApIHtcbiAgICBwPWZyYWN0KHAqdmVjMigxMi45ODk4LDc4LjIzMykpO1xuICAgIHArPWRvdChwLHArMzQuNTYpO1xuICAgIHJldHVybiBmcmFjdChwLngqcC55KTtcbn1cbmZsb2F0IG5vaXNlKHZlYzIgcCkge1xuICAgIHZlYzIgaT1mbG9vcihwKSwgZj1mcmFjdChwKSwgdT1mKmYqKDMuLTIuKmYpLCBrPXZlYzIoMSwwKTtcbiAgICBmbG9hdCBhPXJuZChpKSwgYj1ybmQoaStrKSwgYz1ybmQoaStrLnl4KSwgZD1ybmQoaSsxLik7XG4gICAgcmV0dXJuIG1peChtaXgoYSxiLHUueCksbWl4KGMsZCx1LngpLHUueSk7XG59XG5mbG9hdCBmYm0odmVjMiBwKSB7XG4gICAgZmxvYXQgdD0uMCwgYT0xLiwgaD0uMDsgbWF0MiBtPW1hdDIoMS4sLTEuMiwuMiwxLjIpO1xuICAgIGZvciAoZmxvYXQgaT0uMDsgaTw0LjsgaSsrKSB7XG4gICAgICAgIHQrPWEqbm9pc2UocCk7XG4gICAgICAgIHAqPTIuKm07XG4gICAgICAgIGEqPS41O1xuICAgICAgICBoKz1hO1xuICAgIH1cbiAgICByZXR1cm4gdC9oO1xufVxudm9pZCBtYWluKCkge1xuICAgIHZlYzIgdXY9KEZDLS41KlIpL1IueSwgaz12ZWMyKDAsVCouMDE1KTsgXG4gICAgdmVjMyBjb2w9dmVjMygxKTtcbiAgICB1di54Kz0uMjU7XG4gICAgdXYqPXZlYzIoMiwxKTtcbiAgICBmbG9hdCBuPWZibSh1diouMjgrdmVjMigtVCouMDEsMCkpO1xuICAgIG49bm9pc2UodXYqMy4rbioyLik7XG4gICAgY29sLnItPWZibSh1ditrK24pO1xuICAgIGNvbC5nLT1mYm0odXYqMS4wMDMraytuKy4wMDMpO1xuICAgIGNvbC5iLT1mYm0odXYqMS4wMDYraytuKy4wMDYpO1xuICAgIGNvbD1taXgoY29sLHZlYzMoMSksZG90KGNvbCx2ZWMzKC4yMSwuNzEsLjA3KSkpO1xuICAgIGNvbD1taXgodmVjMyguMDgpLGNvbCxtaW4odGltZSouMSwxLikpO1xuICAgIGNvbD1jbGFtcChjb2wsLjA4LDEuKTtcbiAgICBjb2wuciAqPSAwLjI7XG4gICAgY29sLmcgKj0gMS4wO1xuICAgIGNvbC5iICo9IDAuOTtcbiAgICBPPXZlYzQoY29sLDEpO1xufWBcblxuICBjb25zdCBzZXR1cFdlYkdMID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50XG4gICAgaWYgKCFjYW52YXMpIHJldHVybiBudWxsXG5cbiAgICBjb25zdCBkcHIgPSBpc01vYmlsZSA/IDEgOiBNYXRoLm1pbigxLjUsIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKVxuICAgIGNvbnN0IHsgaW5uZXJXaWR0aDogd2lkdGgsIGlubmVySGVpZ2h0OiBoZWlnaHQgfSA9IHdpbmRvd1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoICogZHByXG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIGRwclxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJywgeyBcbiAgICAgICAgYW50aWFsaWFzOiBmYWxzZSxcbiAgICAgICAgcG93ZXJQcmVmZXJlbmNlOiBpc01vYmlsZSA/ICdsb3ctcG93ZXInIDogJ2hpZ2gtcGVyZm9ybWFuY2UnXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9LCBbaXNNb2JpbGVdKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnRcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuXG5cbiAgICBjb25zdCBnbCA9IHNldHVwV2ViR0woKVxuICAgIGlmICghZ2wpIHJldHVyblxuXG4gICAgbGV0IHJlbmRlcmVyOiBSZW5kZXJlciB8IG51bGwgPSBuZXcgUmVuZGVyZXIoY2FudmFzLCBnbClcbiAgICBsZXQgYW5pbWF0aW9uRnJhbWVJZDogbnVtYmVyXG5cbiAgICBjb25zdCBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgICBjb25zdCBkcHIgPSBpc01vYmlsZSA/IDEgOiBNYXRoLm1pbigxLjUsIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKVxuICAgICAgY29uc3QgeyBpbm5lcldpZHRoOiB3aWR0aCwgaW5uZXJIZWlnaHQ6IGhlaWdodCB9ID0gd2luZG93XG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aCAqIGRwclxuICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIGRwclxuICAgICAgcmVuZGVyZXI/LnVwZGF0ZVNjYWxlKGRwcilcbiAgICB9XG5cbiAgICBjb25zdCBkZWJvdW5jZWRSZXNpemUgPSBkZWJvdW5jZShoYW5kbGVSZXNpemUsIDEwMClcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZGVib3VuY2VkUmVzaXplKVxuXG4gICAgY29uc3QgcmVuZGVyID0gKG5vdzogbnVtYmVyKSA9PiB7XG4gICAgICBpZiAobm93IC0gbGFzdFJlbmRlclJlZi5jdXJyZW50ID49IDEwMDAgLyBmcmFtZVJhdGUpIHtcbiAgICAgICAgcmVuZGVyZXI/LnJlbmRlcihub3cpXG4gICAgICAgIGxhc3RSZW5kZXJSZWYuY3VycmVudCA9IG5vd1xuICAgICAgfVxuICAgICAgYW5pbWF0aW9uRnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXIpXG4gICAgfVxuXG4gICAgcmVuZGVyZXIuaW5pdChmcmFnbWVudFNoYWRlclNvdXJjZSlcbiAgICByZW5kZXIoMClcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZGVib3VuY2VkUmVzaXplKVxuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWVJZClcbiAgICAgIHJlbmRlcmVyPy5jbGVhbnVwKClcbiAgICB9XG4gIH0sIFtmcmFnbWVudFNoYWRlclNvdXJjZSwgaXNNb2JpbGUsIHNldHVwV2ViR0xdKVxuXG4gIHJldHVybiAoXG4gICAgPGNhbnZhcyByZWY9e2NhbnZhc1JlZn0gY2xhc3NOYW1lPVwiZml4ZWQgaW5zZXQtMCB3LWZ1bGwgaC1mdWxsIGJsb2NrXCIgLz5cbiAgKVxufVxuXG5jbGFzcyBSZW5kZXJlciB7XG4gIHByaXZhdGUgZ2w6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHRcbiAgcHJpdmF0ZSBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50XG4gIHByaXZhdGUgcHJvZ3JhbTogV2ViR0xQcm9ncmFtIHwgbnVsbCA9IG51bGxcbiAgcHJpdmF0ZSBidWZmZXI6IFdlYkdMQnVmZmVyIHwgbnVsbCA9IG51bGxcbiAgcHJpdmF0ZSBzY2FsZTogbnVtYmVyXG4gIHByaXZhdGUgdGltZVVuaWZvcm06IFdlYkdMVW5pZm9ybUxvY2F0aW9uIHwgbnVsbCA9IG51bGxcbiAgcHJpdmF0ZSByZXNvbHV0aW9uVW5pZm9ybTogV2ViR0xVbmlmb3JtTG9jYXRpb24gfCBudWxsID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIGdsOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KSB7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXNcbiAgICB0aGlzLmdsID0gZ2xcbiAgICB0aGlzLnNjYWxlID0gMVxuICAgIHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0JylcbiAgfVxuXG4gIGluaXQoc2hhZGVyU291cmNlOiBzdHJpbmcpIHtcbiAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSB0aGlzLmNvbXBpbGVTaGFkZXIodGhpcy5nbC5WRVJURVhfU0hBREVSLCBcbiAgICAgIGAjdmVyc2lvbiAzMDAgZXNcbnByZWNpc2lvbiBsb3dwIGZsb2F0O1xuaW4gdmVjMiBwb3NpdGlvbjtcbnZvaWQgbWFpbigpIHsgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLCAwLjAsIDEuMCk7IH1gXG4gICAgKVxuICAgIFxuICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gdGhpcy5jb21waWxlU2hhZGVyKHRoaXMuZ2wuRlJBR01FTlRfU0hBREVSLCBzaGFkZXJTb3VyY2UpXG5cbiAgICBpZiAoIXZlcnRleFNoYWRlciB8fCAhZnJhZ21lbnRTaGFkZXIpIHJldHVyblxuXG4gICAgdGhpcy5wcm9ncmFtID0gdGhpcy5nbC5jcmVhdGVQcm9ncmFtKClcbiAgICBpZiAoIXRoaXMucHJvZ3JhbSkgcmV0dXJuXG5cbiAgICB0aGlzLmdsLmF0dGFjaFNoYWRlcih0aGlzLnByb2dyYW0sIHZlcnRleFNoYWRlcilcbiAgICB0aGlzLmdsLmF0dGFjaFNoYWRlcih0aGlzLnByb2dyYW0sIGZyYWdtZW50U2hhZGVyKVxuICAgIHRoaXMuZ2wubGlua1Byb2dyYW0odGhpcy5wcm9ncmFtKVxuXG4gICAgaWYgKCF0aGlzLmdsLmdldFByb2dyYW1QYXJhbWV0ZXIodGhpcy5wcm9ncmFtLCB0aGlzLmdsLkxJTktfU1RBVFVTKSkge1xuICAgICAgY29uc29sZS5lcnJvcih0aGlzLmdsLmdldFByb2dyYW1JbmZvTG9nKHRoaXMucHJvZ3JhbSkpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuZ2wuY3JlYXRlQnVmZmVyKClcbiAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKVxuICAgIHRoaXMuZ2wuYnVmZmVyRGF0YSh0aGlzLmdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShbLTEsIDEsIC0xLCAtMSwgMSwgMSwgMSwgLTFdKSwgdGhpcy5nbC5TVEFUSUNfRFJBVylcblxuICAgIGNvbnN0IHBvc2l0aW9uTG9jYXRpb24gPSB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ3Bvc2l0aW9uJylcbiAgICB0aGlzLnRpbWVVbmlmb3JtID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCAndGltZScpXG4gICAgdGhpcy5yZXNvbHV0aW9uVW5pZm9ybSA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ3Jlc29sdXRpb24nKVxuXG4gICAgdGhpcy5nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uKVxuICAgIHRoaXMuZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkxvY2F0aW9uLCAyLCB0aGlzLmdsLkZMT0FULCBmYWxzZSwgMCwgMClcbiAgfVxuXG4gIHByaXZhdGUgY29tcGlsZVNoYWRlcih0eXBlOiBudW1iZXIsIHNvdXJjZTogc3RyaW5nKTogV2ViR0xTaGFkZXIgfCBudWxsIHtcbiAgICBjb25zdCBzaGFkZXIgPSB0aGlzLmdsLmNyZWF0ZVNoYWRlcih0eXBlKVxuICAgIGlmICghc2hhZGVyKSByZXR1cm4gbnVsbFxuXG4gICAgdGhpcy5nbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpXG4gICAgdGhpcy5nbC5jb21waWxlU2hhZGVyKHNoYWRlcilcblxuICAgIGlmICghdGhpcy5nbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCB0aGlzLmdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgY29uc29sZS5lcnJvcih0aGlzLmdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSlcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHJldHVybiBzaGFkZXJcbiAgfVxuXG4gIHVwZGF0ZVNjYWxlKHNjYWxlOiBudW1iZXIpIHtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGVcbiAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpXG4gIH1cblxuICByZW5kZXIodGltZTogbnVtYmVyKSB7XG4gICAgaWYgKCF0aGlzLnByb2dyYW0gfHwgIXRoaXMucmVzb2x1dGlvblVuaWZvcm0gfHwgIXRoaXMudGltZVVuaWZvcm0pIHJldHVyblxuXG4gICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSlcbiAgICB0aGlzLmdsLnVuaWZvcm0xZih0aGlzLnRpbWVVbmlmb3JtLCB0aW1lICogMC4wMDEpXG4gICAgdGhpcy5nbC51bmlmb3JtMmYodGhpcy5yZXNvbHV0aW9uVW5pZm9ybSwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodClcbiAgICB0aGlzLmdsLmRyYXdBcnJheXModGhpcy5nbC5UUklBTkdMRV9TVFJJUCwgMCwgNClcbiAgfVxuXG4gIGNsZWFudXAoKSB7XG4gICAgdGhpcy5nbC5kZWxldGVQcm9ncmFtKHRoaXMucHJvZ3JhbSlcbiAgICB0aGlzLmdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmJ1ZmZlcilcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWJvdW5jZTxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkPihmbjogVCwgZGVsYXk6IG51bWJlcikge1xuICBsZXQgdGltZW91dDogTm9kZUpTLlRpbWVvdXRcbiAgcmV0dXJuICguLi5hcmdzOiBQYXJhbWV0ZXJzPFQ+KSA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gZm4oLi4uYXJncyksIGRlbGF5KVxuICB9XG59Il0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZUNhbGxiYWNrIiwiRmx1aWRTaGFkZXIiLCJjYW52YXNSZWYiLCJsYXN0UmVuZGVyUmVmIiwiZnJhbWVSYXRlIiwiaXNNb2JpbGUiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiZnJhZ21lbnRTaGFkZXJTb3VyY2UiLCJzZXR1cFdlYkdMIiwiY2FudmFzIiwiY3VycmVudCIsImRwciIsIk1hdGgiLCJtaW4iLCJ3aW5kb3ciLCJkZXZpY2VQaXhlbFJhdGlvIiwiaW5uZXJXaWR0aCIsIndpZHRoIiwiaW5uZXJIZWlnaHQiLCJoZWlnaHQiLCJnZXRDb250ZXh0IiwiYW50aWFsaWFzIiwicG93ZXJQcmVmZXJlbmNlIiwiZSIsImdsIiwicmVuZGVyZXIiLCJSZW5kZXJlciIsImFuaW1hdGlvbkZyYW1lSWQiLCJoYW5kbGVSZXNpemUiLCJ1cGRhdGVTY2FsZSIsImRlYm91bmNlZFJlc2l6ZSIsImRlYm91bmNlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbmRlciIsIm5vdyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImluaXQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJjbGVhbnVwIiwicmVmIiwiY2xhc3NOYW1lIiwic2hhZGVyU291cmNlIiwidmVydGV4U2hhZGVyIiwiY29tcGlsZVNoYWRlciIsIlZFUlRFWF9TSEFERVIiLCJmcmFnbWVudFNoYWRlciIsIkZSQUdNRU5UX1NIQURFUiIsInByb2dyYW0iLCJjcmVhdGVQcm9ncmFtIiwiYXR0YWNoU2hhZGVyIiwibGlua1Byb2dyYW0iLCJnZXRQcm9ncmFtUGFyYW1ldGVyIiwiTElOS19TVEFUVVMiLCJjb25zb2xlIiwiZXJyb3IiLCJnZXRQcm9ncmFtSW5mb0xvZyIsImJ1ZmZlciIsImNyZWF0ZUJ1ZmZlciIsImJpbmRCdWZmZXIiLCJBUlJBWV9CVUZGRVIiLCJidWZmZXJEYXRhIiwiRmxvYXQzMkFycmF5IiwiU1RBVElDX0RSQVciLCJwb3NpdGlvbkxvY2F0aW9uIiwiZ2V0QXR0cmliTG9jYXRpb24iLCJ0aW1lVW5pZm9ybSIsImdldFVuaWZvcm1Mb2NhdGlvbiIsInJlc29sdXRpb25Vbmlmb3JtIiwiZW5hYmxlVmVydGV4QXR0cmliQXJyYXkiLCJ2ZXJ0ZXhBdHRyaWJQb2ludGVyIiwiRkxPQVQiLCJ0eXBlIiwic291cmNlIiwic2hhZGVyIiwiY3JlYXRlU2hhZGVyIiwiZ2V0U2hhZGVyUGFyYW1ldGVyIiwiQ09NUElMRV9TVEFUVVMiLCJnZXRTaGFkZXJJbmZvTG9nIiwic2NhbGUiLCJ2aWV3cG9ydCIsInRpbWUiLCJ1c2VQcm9ncmFtIiwidW5pZm9ybTFmIiwidW5pZm9ybTJmIiwiZHJhd0FycmF5cyIsIlRSSUFOR0xFX1NUUklQIiwiZGVsZXRlUHJvZ3JhbSIsImRlbGV0ZUJ1ZmZlciIsImNvbnN0cnVjdG9yIiwiZ2V0RXh0ZW5zaW9uIiwiZm4iLCJkZWxheSIsInRpbWVvdXQiLCJhcmdzIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/fluid-shader.tsx\n"));

/***/ })

});