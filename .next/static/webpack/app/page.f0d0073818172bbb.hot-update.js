"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/fluid-shader.tsx":
/*!*****************************************!*\
  !*** ./src/components/fluid-shader.tsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FluidShader)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction FluidShader() {\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const lastRenderRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const frameRate = 30 // Target 30 FPS for better performance\n    ;\n    const isMobile =  true ? /Mobi|Android/i.test(navigator.userAgent) : 0;\n    const fragmentShaderSource = \"#version 300 es\\n    precision mediump float;\\n    out vec4 O;\\n    uniform float time;\\n    uniform vec2 resolution;\\n    #define FC gl_FragCoord.xy\\n    #define R resolution\\n    #define T (time+660.)\\n    #define S smoothstep\\n    #define N normalize\\n    float rnd(vec2 p) {\\n        p=fract(p*vec2(12.9898,78.233));\\n        p+=dot(p,p+34.56);\\n        return fract(p.x*p.y);\\n    }\\n    float noise(vec2 p) {\\n        vec2 i=floor(p), f=fract(p), u=f*f*(3.-2.*f), k=vec2(1,0);\\n        float a=rnd(i), b=rnd(i+k), c=rnd(i+k.yx), d=rnd(i+1.);\\n        return mix(mix(a,b,u.x),mix(c,d,u.x),u.y);\\n    }\\n    float fbm(vec2 p) {\\n        float t=.0, a=1., h=.0; mat2 m=mat2(1.,-1.2,.2,1.2);\\n        for (float i=.0; i<4.; i++) {\\n            t+=a*noise(p);\\n            p*=2.*m;\\n            a*=.5;\\n            h+=a;\\n        }\\n        return t/h;\\n    }\\n    void main() {\\n        vec2 uv=(FC-.5*R)/R.y, k=vec2(0,T*.015); \\n        vec3 col=vec3(1);\\n        uv.x+=.25;\\n        uv*=vec2(2,1);\\n        float n=fbm(uv*.28+vec2(-T*.01,0));\\n        n=noise(uv*3.+n*2.);\\n        col.r-=fbm(uv+k+n);\\n        col.g-=fbm(uv*1.003+k+n+.003);\\n        col.b-=fbm(uv*1.006+k+n+.006);\\n        col=mix(col,vec3(1),dot(col,vec3(.21,.71,.07)));\\n        col=mix(vec3(.08),col,min(time*.1,1.));\\n        col=clamp(col,.08,1.);\\n        col.r *= 0.2;\\n        col.g *= 1.0;\\n        col.b *= 0.9;\\n        O=vec4(col,1);\\n    }\";\n    const setupWebGL = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"FluidShader.useCallback[setupWebGL]\": ()=>{\n            const canvas = canvasRef.current;\n            if (!canvas) return null;\n            const dpr = isMobile ? 1 : Math.min(1.5, window.devicePixelRatio);\n            const { innerWidth: width, innerHeight: height } = window;\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n            try {\n                return canvas.getContext('webgl2', {\n                    antialias: false,\n                    powerPreference: isMobile ? 'low-power' : 'high-performance'\n                });\n            } catch (e) {\n                return null;\n            }\n        }\n    }[\"FluidShader.useCallback[setupWebGL]\"], [\n        isMobile\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"FluidShader.useEffect\": ()=>{\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            const gl = setupWebGL();\n            if (!gl) return;\n            let renderer = new Renderer(canvas, gl);\n            let animationFrameId;\n            const handleResize = {\n                \"FluidShader.useEffect.handleResize\": ()=>{\n                    const dpr = isMobile ? 1 : Math.min(1.5, window.devicePixelRatio);\n                    const { innerWidth: width, innerHeight: height } = window;\n                    canvas.width = width * dpr;\n                    canvas.height = height * dpr;\n                    renderer === null || renderer === void 0 ? void 0 : renderer.updateScale(dpr);\n                }\n            }[\"FluidShader.useEffect.handleResize\"];\n            const debouncedResize = debounce(handleResize, 100);\n            window.addEventListener('resize', debouncedResize);\n            const render = {\n                \"FluidShader.useEffect.render\": (now)=>{\n                    if (now - lastRenderRef.current >= 1000 / frameRate) {\n                        renderer === null || renderer === void 0 ? void 0 : renderer.render(now);\n                        lastRenderRef.current = now;\n                    }\n                    animationFrameId = requestAnimationFrame(render);\n                }\n            }[\"FluidShader.useEffect.render\"];\n            renderer.init(fragmentShaderSource);\n            render(0);\n            return ({\n                \"FluidShader.useEffect\": ()=>{\n                    window.removeEventListener('resize', debouncedResize);\n                    cancelAnimationFrame(animationFrameId);\n                    renderer === null || renderer === void 0 ? void 0 : renderer.cleanup();\n                }\n            })[\"FluidShader.useEffect\"];\n        }\n    }[\"FluidShader.useEffect\"], [\n        fragmentShaderSource,\n        isMobile,\n        setupWebGL\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        className: \"fixed inset-0 w-full h-full block\"\n    }, void 0, false, {\n        fileName: \"/Users/nitishkumar/Desktop/verbose-pancake/src/components/fluid-shader.tsx\",\n        lineNumber: 119,\n        columnNumber: 5\n    }, this);\n}\n_s(FluidShader, \"rN7eYWVNVHgJ/Fd8evCyaHGm+kw=\");\n_c = FluidShader;\nclass Renderer {\n    init(shaderSource) {\n        const vertexShader = this.compileShader(this.gl.VERTEX_SHADER, \"\\n      #version 300 es\\n      precision lowp float;\\n      in vec2 position;\\n      void main() { gl_Position = vec4(position, 0.0, 1.0); }\\n    \");\n        const fragmentShader = this.compileShader(this.gl.FRAGMENT_SHADER, shaderSource);\n        if (!vertexShader || !fragmentShader) return;\n        this.program = this.gl.createProgram();\n        if (!this.program) return;\n        this.gl.attachShader(this.program, vertexShader);\n        this.gl.attachShader(this.program, fragmentShader);\n        this.gl.linkProgram(this.program);\n        if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {\n            console.error(this.gl.getProgramInfoLog(this.program));\n            return;\n        }\n        this.buffer = this.gl.createBuffer();\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([\n            -1,\n            1,\n            -1,\n            -1,\n            1,\n            1,\n            1,\n            -1\n        ]), this.gl.STATIC_DRAW);\n        const positionLocation = this.gl.getAttribLocation(this.program, 'position');\n        this.timeUniform = this.gl.getUniformLocation(this.program, 'time');\n        this.resolutionUniform = this.gl.getUniformLocation(this.program, 'resolution');\n        this.gl.enableVertexAttribArray(positionLocation);\n        this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 0, 0);\n    }\n    compileShader(type, source) {\n        const shader = this.gl.createShader(type);\n        if (!shader) return null;\n        this.gl.shaderSource(shader, source);\n        this.gl.compileShader(shader);\n        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\n            console.error(this.gl.getShaderInfoLog(shader));\n            return null;\n        }\n        return shader;\n    }\n    updateScale(scale) {\n        this.scale = scale;\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n    }\n    render(time) {\n        if (!this.program || !this.resolutionUniform || !this.timeUniform) return;\n        this.gl.useProgram(this.program);\n        this.gl.uniform1f(this.timeUniform, time * 0.001);\n        this.gl.uniform2f(this.resolutionUniform, this.canvas.width, this.canvas.height);\n        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);\n    }\n    cleanup() {\n        this.gl.deleteProgram(this.program);\n        this.gl.deleteBuffer(this.buffer);\n    }\n    constructor(canvas, gl){\n        this.program = null;\n        this.buffer = null;\n        this.timeUniform = null;\n        this.resolutionUniform = null;\n        this.canvas = canvas;\n        this.gl = gl;\n        this.scale = 1;\n        this.gl.getExtension('EXT_color_buffer_float');\n    }\n}\nfunction debounce(fn, delay) {\n    let timeout;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        clearTimeout(timeout);\n        timeout = setTimeout(()=>fn(...args), delay);\n    };\n}\nvar _c;\n$RefreshReg$(_c, \"FluidShader\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2ZsdWlkLXNoYWRlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRXNEO0FBRXZDLFNBQVNHOztJQUN0QixNQUFNQyxZQUFZSCw2Q0FBTUEsQ0FBb0I7SUFDNUMsTUFBTUksZ0JBQWdCSiw2Q0FBTUEsQ0FBQztJQUM3QixNQUFNSyxZQUFZLEdBQUcsdUNBQXVDOztJQUM1RCxNQUFNQyxXQUFXLEtBQTZCLEdBQUcsZ0JBQWdCQyxJQUFJLENBQUNDLFVBQVVDLFNBQVMsSUFBSSxDQUFLO0lBRWxHLE1BQU1DLHVCQUF3QjtJQWlEOUIsTUFBTUMsYUFBYVYsa0RBQVdBOytDQUFDO1lBQzdCLE1BQU1XLFNBQVNULFVBQVVVLE9BQU87WUFDaEMsSUFBSSxDQUFDRCxRQUFRLE9BQU87WUFFcEIsTUFBTUUsTUFBTVIsV0FBVyxJQUFJUyxLQUFLQyxHQUFHLENBQUMsS0FBS0MsT0FBT0MsZ0JBQWdCO1lBQ2hFLE1BQU0sRUFBRUMsWUFBWUMsS0FBSyxFQUFFQyxhQUFhQyxNQUFNLEVBQUUsR0FBR0w7WUFDbkRMLE9BQU9RLEtBQUssR0FBR0EsUUFBUU47WUFDdkJGLE9BQU9VLE1BQU0sR0FBR0EsU0FBU1I7WUFFekIsSUFBSTtnQkFDRixPQUFPRixPQUFPVyxVQUFVLENBQUMsVUFBVTtvQkFDakNDLFdBQVc7b0JBQ1hDLGlCQUFpQm5CLFdBQVcsY0FBYztnQkFDNUM7WUFDRixFQUFFLE9BQU9vQixHQUFHO2dCQUNWLE9BQU87WUFDVDtRQUNGOzhDQUFHO1FBQUNwQjtLQUFTO0lBRWJQLGdEQUFTQTtpQ0FBQztZQUNSLE1BQU1hLFNBQVNULFVBQVVVLE9BQU87WUFDaEMsSUFBSSxDQUFDRCxRQUFRO1lBRWIsTUFBTWUsS0FBS2hCO1lBQ1gsSUFBSSxDQUFDZ0IsSUFBSTtZQUVULElBQUlDLFdBQTRCLElBQUlDLFNBQVNqQixRQUFRZTtZQUNyRCxJQUFJRztZQUVKLE1BQU1DO3NEQUFlO29CQUNuQixNQUFN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O0lBQzFDO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9uaXRpc2hrdW1hci9EZXNrdG9wL3ZlcmJvc2UtcGFuY2FrZS9zcmMvY29tcG9uZW50cy9mbHVpZC1zaGFkZXIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiXG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VDYWxsYmFjayB9IGZyb20gXCJyZWFjdFwiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsdWlkU2hhZGVyKCkge1xuICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWY8SFRNTENhbnZhc0VsZW1lbnQ+KG51bGwpXG4gIGNvbnN0IGxhc3RSZW5kZXJSZWYgPSB1c2VSZWYoMClcbiAgY29uc3QgZnJhbWVSYXRlID0gMzAgLy8gVGFyZ2V0IDMwIEZQUyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG4gIGNvbnN0IGlzTW9iaWxlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyAvTW9iaXxBbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSA6IGZhbHNlXG5cbiAgY29uc3QgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgI3ZlcnNpb24gMzAwIGVzXG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgb3V0IHZlYzQgTztcbiAgICB1bmlmb3JtIGZsb2F0IHRpbWU7XG4gICAgdW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XG4gICAgI2RlZmluZSBGQyBnbF9GcmFnQ29vcmQueHlcbiAgICAjZGVmaW5lIFIgcmVzb2x1dGlvblxuICAgICNkZWZpbmUgVCAodGltZSs2NjAuKVxuICAgICNkZWZpbmUgUyBzbW9vdGhzdGVwXG4gICAgI2RlZmluZSBOIG5vcm1hbGl6ZVxuICAgIGZsb2F0IHJuZCh2ZWMyIHApIHtcbiAgICAgICAgcD1mcmFjdChwKnZlYzIoMTIuOTg5OCw3OC4yMzMpKTtcbiAgICAgICAgcCs9ZG90KHAscCszNC41Nik7XG4gICAgICAgIHJldHVybiBmcmFjdChwLngqcC55KTtcbiAgICB9XG4gICAgZmxvYXQgbm9pc2UodmVjMiBwKSB7XG4gICAgICAgIHZlYzIgaT1mbG9vcihwKSwgZj1mcmFjdChwKSwgdT1mKmYqKDMuLTIuKmYpLCBrPXZlYzIoMSwwKTtcbiAgICAgICAgZmxvYXQgYT1ybmQoaSksIGI9cm5kKGkrayksIGM9cm5kKGkray55eCksIGQ9cm5kKGkrMS4pO1xuICAgICAgICByZXR1cm4gbWl4KG1peChhLGIsdS54KSxtaXgoYyxkLHUueCksdS55KTtcbiAgICB9XG4gICAgZmxvYXQgZmJtKHZlYzIgcCkge1xuICAgICAgICBmbG9hdCB0PS4wLCBhPTEuLCBoPS4wOyBtYXQyIG09bWF0MigxLiwtMS4yLC4yLDEuMik7XG4gICAgICAgIGZvciAoZmxvYXQgaT0uMDsgaTw0LjsgaSsrKSB7XG4gICAgICAgICAgICB0Kz1hKm5vaXNlKHApO1xuICAgICAgICAgICAgcCo9Mi4qbTtcbiAgICAgICAgICAgIGEqPS41O1xuICAgICAgICAgICAgaCs9YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdC9oO1xuICAgIH1cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIHZlYzIgdXY9KEZDLS41KlIpL1IueSwgaz12ZWMyKDAsVCouMDE1KTsgXG4gICAgICAgIHZlYzMgY29sPXZlYzMoMSk7XG4gICAgICAgIHV2LngrPS4yNTtcbiAgICAgICAgdXYqPXZlYzIoMiwxKTtcbiAgICAgICAgZmxvYXQgbj1mYm0odXYqLjI4K3ZlYzIoLVQqLjAxLDApKTtcbiAgICAgICAgbj1ub2lzZSh1diozLituKjIuKTtcbiAgICAgICAgY29sLnItPWZibSh1ditrK24pO1xuICAgICAgICBjb2wuZy09ZmJtKHV2KjEuMDAzK2srbisuMDAzKTtcbiAgICAgICAgY29sLmItPWZibSh1dioxLjAwNitrK24rLjAwNik7XG4gICAgICAgIGNvbD1taXgoY29sLHZlYzMoMSksZG90KGNvbCx2ZWMzKC4yMSwuNzEsLjA3KSkpO1xuICAgICAgICBjb2w9bWl4KHZlYzMoLjA4KSxjb2wsbWluKHRpbWUqLjEsMS4pKTtcbiAgICAgICAgY29sPWNsYW1wKGNvbCwuMDgsMS4pO1xuICAgICAgICBjb2wuciAqPSAwLjI7XG4gICAgICAgIGNvbC5nICo9IDEuMDtcbiAgICAgICAgY29sLmIgKj0gMC45O1xuICAgICAgICBPPXZlYzQoY29sLDEpO1xuICAgIH1gXG5cbiAgY29uc3Qgc2V0dXBXZWJHTCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudFxuICAgIGlmICghY2FudmFzKSByZXR1cm4gbnVsbFxuXG4gICAgY29uc3QgZHByID0gaXNNb2JpbGUgPyAxIDogTWF0aC5taW4oMS41LCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbylcbiAgICBjb25zdCB7IGlubmVyV2lkdGg6IHdpZHRoLCBpbm5lckhlaWdodDogaGVpZ2h0IH0gPSB3aW5kb3dcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aCAqIGRwclxuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBkcHJcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicsIHsgXG4gICAgICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgICAgIHBvd2VyUHJlZmVyZW5jZTogaXNNb2JpbGUgPyAnbG93LXBvd2VyJyA6ICdoaWdoLXBlcmZvcm1hbmNlJ1xuICAgICAgfSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfSwgW2lzTW9iaWxlXSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50XG4gICAgaWYgKCFjYW52YXMpIHJldHVyblxuXG4gICAgY29uc3QgZ2wgPSBzZXR1cFdlYkdMKClcbiAgICBpZiAoIWdsKSByZXR1cm5cblxuICAgIGxldCByZW5kZXJlcjogUmVuZGVyZXIgfCBudWxsID0gbmV3IFJlbmRlcmVyKGNhbnZhcywgZ2wpXG4gICAgbGV0IGFuaW1hdGlvbkZyYW1lSWQ6IG51bWJlclxuXG4gICAgY29uc3QgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgY29uc3QgZHByID0gaXNNb2JpbGUgPyAxIDogTWF0aC5taW4oMS41LCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbylcbiAgICAgIGNvbnN0IHsgaW5uZXJXaWR0aDogd2lkdGgsIGlubmVySGVpZ2h0OiBoZWlnaHQgfSA9IHdpbmRvd1xuICAgICAgY2FudmFzLndpZHRoID0gd2lkdGggKiBkcHJcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBkcHJcbiAgICAgIHJlbmRlcmVyPy51cGRhdGVTY2FsZShkcHIpXG4gICAgfVxuXG4gICAgY29uc3QgZGVib3VuY2VkUmVzaXplID0gZGVib3VuY2UoaGFuZGxlUmVzaXplLCAxMDApXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGRlYm91bmNlZFJlc2l6ZSlcblxuICAgIGNvbnN0IHJlbmRlciA9IChub3c6IG51bWJlcikgPT4ge1xuICAgICAgaWYgKG5vdyAtIGxhc3RSZW5kZXJSZWYuY3VycmVudCA+PSAxMDAwIC8gZnJhbWVSYXRlKSB7XG4gICAgICAgIHJlbmRlcmVyPy5yZW5kZXIobm93KVxuICAgICAgICBsYXN0UmVuZGVyUmVmLmN1cnJlbnQgPSBub3dcbiAgICAgIH1cbiAgICAgIGFuaW1hdGlvbkZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyKVxuICAgIH1cblxuICAgIHJlbmRlcmVyLmluaXQoZnJhZ21lbnRTaGFkZXJTb3VyY2UpXG4gICAgcmVuZGVyKDApXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGRlYm91bmNlZFJlc2l6ZSlcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lSWQpXG4gICAgICByZW5kZXJlcj8uY2xlYW51cCgpXG4gICAgfVxuICB9LCBbZnJhZ21lbnRTaGFkZXJTb3VyY2UsIGlzTW9iaWxlLCBzZXR1cFdlYkdMXSlcblxuICByZXR1cm4gKFxuICAgIDxjYW52YXMgcmVmPXtjYW52YXNSZWZ9IGNsYXNzTmFtZT1cImZpeGVkIGluc2V0LTAgdy1mdWxsIGgtZnVsbCBibG9ja1wiIC8+XG4gIClcbn1cblxuY2xhc3MgUmVuZGVyZXIge1xuICBwcml2YXRlIGdsOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0XG4gIHByaXZhdGUgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudFxuICBwcml2YXRlIHByb2dyYW06IFdlYkdMUHJvZ3JhbSB8IG51bGwgPSBudWxsXG4gIHByaXZhdGUgYnVmZmVyOiBXZWJHTEJ1ZmZlciB8IG51bGwgPSBudWxsXG4gIHByaXZhdGUgc2NhbGU6IG51bWJlclxuICBwcml2YXRlIHRpbWVVbmlmb3JtOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiB8IG51bGwgPSBudWxsXG4gIHByaXZhdGUgcmVzb2x1dGlvblVuaWZvcm06IFdlYkdMVW5pZm9ybUxvY2F0aW9uIHwgbnVsbCA9IG51bGxcblxuICBjb25zdHJ1Y3RvcihjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCBnbDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkge1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzXG4gICAgdGhpcy5nbCA9IGdsXG4gICAgdGhpcy5zY2FsZSA9IDFcbiAgICB0aGlzLmdsLmdldEV4dGVuc2lvbignRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcpXG4gIH1cblxuICBpbml0KHNoYWRlclNvdXJjZTogc3RyaW5nKSB7XG4gICAgY29uc3QgdmVydGV4U2hhZGVyID0gdGhpcy5jb21waWxlU2hhZGVyKHRoaXMuZ2wuVkVSVEVYX1NIQURFUiwgYFxuICAgICAgI3ZlcnNpb24gMzAwIGVzXG4gICAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAgIGluIHZlYzIgcG9zaXRpb247XG4gICAgICB2b2lkIG1haW4oKSB7IGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMC4wLCAxLjApOyB9XG4gICAgYClcbiAgICBcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9IHRoaXMuY29tcGlsZVNoYWRlcih0aGlzLmdsLkZSQUdNRU5UX1NIQURFUiwgc2hhZGVyU291cmNlKVxuXG4gICAgaWYgKCF2ZXJ0ZXhTaGFkZXIgfHwgIWZyYWdtZW50U2hhZGVyKSByZXR1cm5cblxuICAgIHRoaXMucHJvZ3JhbSA9IHRoaXMuZ2wuY3JlYXRlUHJvZ3JhbSgpXG4gICAgaWYgKCF0aGlzLnByb2dyYW0pIHJldHVyblxuXG4gICAgdGhpcy5nbC5hdHRhY2hTaGFkZXIodGhpcy5wcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpXG4gICAgdGhpcy5nbC5hdHRhY2hTaGFkZXIodGhpcy5wcm9ncmFtLCBmcmFnbWVudFNoYWRlcilcbiAgICB0aGlzLmdsLmxpbmtQcm9ncmFtKHRoaXMucHJvZ3JhbSlcblxuICAgIGlmICghdGhpcy5nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHRoaXMucHJvZ3JhbSwgdGhpcy5nbC5MSU5LX1NUQVRVUykpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IodGhpcy5nbC5nZXRQcm9ncmFtSW5mb0xvZyh0aGlzLnByb2dyYW0pKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5idWZmZXIgPSB0aGlzLmdsLmNyZWF0ZUJ1ZmZlcigpXG4gICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcilcbiAgICB0aGlzLmdsLmJ1ZmZlckRhdGEodGhpcy5nbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoWy0xLCAxLCAtMSwgLTEsIDEsIDEsIDEsIC0xXSksIHRoaXMuZ2wuU1RBVElDX0RSQVcpXG5cbiAgICBjb25zdCBwb3NpdGlvbkxvY2F0aW9uID0gdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sICdwb3NpdGlvbicpXG4gICAgdGhpcy50aW1lVW5pZm9ybSA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ3RpbWUnKVxuICAgIHRoaXMucmVzb2x1dGlvblVuaWZvcm0gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sICdyZXNvbHV0aW9uJylcblxuICAgIHRoaXMuZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbilcbiAgICB0aGlzLmdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25Mb2NhdGlvbiwgMiwgdGhpcy5nbC5GTE9BVCwgZmFsc2UsIDAsIDApXG4gIH1cblxuICBwcml2YXRlIGNvbXBpbGVTaGFkZXIodHlwZTogbnVtYmVyLCBzb3VyY2U6IHN0cmluZyk6IFdlYkdMU2hhZGVyIHwgbnVsbCB7XG4gICAgY29uc3Qgc2hhZGVyID0gdGhpcy5nbC5jcmVhdGVTaGFkZXIodHlwZSlcbiAgICBpZiAoIXNoYWRlcikgcmV0dXJuIG51bGxcblxuICAgIHRoaXMuZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKVxuICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpXG5cbiAgICBpZiAoIXRoaXMuZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgdGhpcy5nbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IodGhpcy5nbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICByZXR1cm4gc2hhZGVyXG4gIH1cblxuICB1cGRhdGVTY2FsZShzY2FsZTogbnVtYmVyKSB7XG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlXG4gICAgdGhpcy5nbC52aWV3cG9ydCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KVxuICB9XG5cbiAgcmVuZGVyKHRpbWU6IG51bWJlcikge1xuICAgIGlmICghdGhpcy5wcm9ncmFtIHx8ICF0aGlzLnJlc29sdXRpb25Vbmlmb3JtIHx8ICF0aGlzLnRpbWVVbmlmb3JtKSByZXR1cm5cblxuICAgIHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pXG4gICAgdGhpcy5nbC51bmlmb3JtMWYodGhpcy50aW1lVW5pZm9ybSwgdGltZSAqIDAuMDAxKVxuICAgIHRoaXMuZ2wudW5pZm9ybTJmKHRoaXMucmVzb2x1dGlvblVuaWZvcm0sIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpXG4gICAgdGhpcy5nbC5kcmF3QXJyYXlzKHRoaXMuZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpXG4gIH1cblxuICBjbGVhbnVwKCkge1xuICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbSh0aGlzLnByb2dyYW0pXG4gICAgdGhpcy5nbC5kZWxldGVCdWZmZXIodGhpcy5idWZmZXIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZGVib3VuY2U8VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZD4oZm46IFQsIGRlbGF5OiBudW1iZXIpIHtcbiAgbGV0IHRpbWVvdXQ6IE5vZGVKUy5UaW1lb3V0XG4gIHJldHVybiAoLi4uYXJnczogUGFyYW1ldGVyczxUPikgPT4ge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KVxuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGZuKC4uLmFyZ3MpLCBkZWxheSlcbiAgfVxufSJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VDYWxsYmFjayIsIkZsdWlkU2hhZGVyIiwiY2FudmFzUmVmIiwibGFzdFJlbmRlclJlZiIsImZyYW1lUmF0ZSIsImlzTW9iaWxlIiwidGVzdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImZyYWdtZW50U2hhZGVyU291cmNlIiwic2V0dXBXZWJHTCIsImNhbnZhcyIsImN1cnJlbnQiLCJkcHIiLCJNYXRoIiwibWluIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsImlubmVyV2lkdGgiLCJ3aWR0aCIsImlubmVySGVpZ2h0IiwiaGVpZ2h0IiwiZ2V0Q29udGV4dCIsImFudGlhbGlhcyIsInBvd2VyUHJlZmVyZW5jZSIsImUiLCJnbCIsInJlbmRlcmVyIiwiUmVuZGVyZXIiLCJhbmltYXRpb25GcmFtZUlkIiwiaGFuZGxlUmVzaXplIiwidXBkYXRlU2NhbGUiLCJkZWJvdW5jZWRSZXNpemUiLCJkZWJvdW5jZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW5kZXIiLCJub3ciLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJpbml0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiY2xlYW51cCIsInJlZiIsImNsYXNzTmFtZSIsInNoYWRlclNvdXJjZSIsInZlcnRleFNoYWRlciIsImNvbXBpbGVTaGFkZXIiLCJWRVJURVhfU0hBREVSIiwiZnJhZ21lbnRTaGFkZXIiLCJGUkFHTUVOVF9TSEFERVIiLCJwcm9ncmFtIiwiY3JlYXRlUHJvZ3JhbSIsImF0dGFjaFNoYWRlciIsImxpbmtQcm9ncmFtIiwiZ2V0UHJvZ3JhbVBhcmFtZXRlciIsIkxJTktfU1RBVFVTIiwiY29uc29sZSIsImVycm9yIiwiZ2V0UHJvZ3JhbUluZm9Mb2ciLCJidWZmZXIiLCJjcmVhdGVCdWZmZXIiLCJiaW5kQnVmZmVyIiwiQVJSQVlfQlVGRkVSIiwiYnVmZmVyRGF0YSIsIkZsb2F0MzJBcnJheSIsIlNUQVRJQ19EUkFXIiwicG9zaXRpb25Mb2NhdGlvbiIsImdldEF0dHJpYkxvY2F0aW9uIiwidGltZVVuaWZvcm0iLCJnZXRVbmlmb3JtTG9jYXRpb24iLCJyZXNvbHV0aW9uVW5pZm9ybSIsImVuYWJsZVZlcnRleEF0dHJpYkFycmF5IiwidmVydGV4QXR0cmliUG9pbnRlciIsIkZMT0FUIiwidHlwZSIsInNvdXJjZSIsInNoYWRlciIsImNyZWF0ZVNoYWRlciIsImdldFNoYWRlclBhcmFtZXRlciIsIkNPTVBJTEVfU1RBVFVTIiwiZ2V0U2hhZGVySW5mb0xvZyIsInNjYWxlIiwidmlld3BvcnQiLCJ0aW1lIiwidXNlUHJvZ3JhbSIsInVuaWZvcm0xZiIsInVuaWZvcm0yZiIsImRyYXdBcnJheXMiLCJUUklBTkdMRV9TVFJJUCIsImRlbGV0ZVByb2dyYW0iLCJkZWxldGVCdWZmZXIiLCJjb25zdHJ1Y3RvciIsImdldEV4dGVuc2lvbiIsImZuIiwiZGVsYXkiLCJ0aW1lb3V0IiwiYXJncyIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/fluid-shader.tsx\n"));

/***/ })

});