"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/fluid-shader.tsx":
/*!*****************************************!*\
  !*** ./src/components/fluid-shader.tsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FluidShader)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nconst TARGET_FPS = 30;\nconst FRAME_INTERVAL = 1000 / TARGET_FPS;\nconst MAX_DPR = 1.5;\nconst CANVAS_SCALE = 0.75;\nfunction debounce(func, wait) {\n    let timeout = null;\n    return ()=>{\n        timeout && clearTimeout(timeout);\n        timeout = setTimeout(func, wait);\n    };\n}\nfunction FluidShader() {\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"FluidShader.useEffect\": ()=>{\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            let renderer = null;\n            const dpr = Math.min(MAX_DPR, window.devicePixelRatio) * CANVAS_SCALE;\n            const resize = {\n                \"FluidShader.useEffect.resize\": ()=>{\n                    if (!canvas) return;\n                    const { innerWidth: width, innerHeight: height } = window;\n                    canvas.width = width * dpr;\n                    canvas.height = height * dpr;\n                    canvas.style.width = \"\".concat(width, \"px\");\n                    canvas.style.height = \"\".concat(height, \"px\");\n                    renderer === null || renderer === void 0 ? void 0 : renderer.updateScale(dpr);\n                }\n            }[\"FluidShader.useEffect.resize\"];\n            const debouncedResize = debounce(resize, 100);\n            window.addEventListener(\"resize\", debouncedResize);\n            const fragmentShaderSource = \"#version 300 es\\n    precision mediump float;\\n    out vec4 O;\\n    uniform float time;\\n    uniform vec2 resolution;\\n    \\n    float rnd(vec2 p) {\\n        p = fract(p * vec2(12.9898, 78.233));\\n        return fract(p.x * p.y * (p.x + p.y));\\n    }\\n\\n    float noise(vec2 p) {\\n        vec2 i = floor(p), f = fract(p);\\n        float a = rnd(i), b = rnd(i + vec2(1,0));\\n        float c = rnd(i + vec2(0,1)), d = rnd(i + vec2(1,1));\\n        vec2 u = f * f * (3.0 - 2.0 * f);\\n        return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\\n    }\\n\\n    float fbm(vec2 p) {\\n        float t = 0.0, a = 0.5;\\n        mat2 m = mat2(0.8, 0.6, -0.6, 0.8);\\n        for (int i = 0; i < 3; i++) {\\n            t += a * noise(p);\\n            p *= 2.0 * m;\\n            a *= 0.5;\\n        }\\n        return t * 2.0;\\n    }\\n\\n    void main() {\\n        vec2 uv = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\\n        float t = time * 0.5;\\n        \\n        float n = fbm(uv * 1.5 + vec2(t * 0.3, t * 0.2));\\n        float r = fbm(uv * 2.0 + n + vec2(t * 0.1, t * 0.3));\\n        float b = fbm(uv * 2.5 - n + vec2(t * 0.2, t * 0.4));\\n        \\n        vec3 col = vec3(r * 0.5, n * 0.8, b * 0.9);\\n        col = clamp(col * 0.8 + 0.2, 0.0, 1.0);\\n        O = vec4(col, 1.0);\\n    }\";\n            renderer = new Renderer(canvas, dpr);\n            renderer.setup();\n            renderer.init();\n            resize();\n            if (renderer.test(fragmentShaderSource) === null) {\n                renderer.updateShader(fragmentShaderSource);\n            }\n            let lastRender = 0;\n            let animationFrameId;\n            const loop = {\n                \"FluidShader.useEffect.loop\": (now)=>{\n                    animationFrameId = requestAnimationFrame(loop);\n                    const delta = now - lastRender;\n                    if (delta < FRAME_INTERVAL) return;\n                    lastRender = now;\n                    renderer === null || renderer === void 0 ? void 0 : renderer.render(now);\n                }\n            }[\"FluidShader.useEffect.loop\"];\n            loop(0);\n            return ({\n                \"FluidShader.useEffect\": ()=>{\n                    window.removeEventListener(\"resize\", debouncedResize);\n                    cancelAnimationFrame(animationFrameId);\n                    renderer === null || renderer === void 0 ? void 0 : renderer.reset();\n                }\n            })[\"FluidShader.useEffect\"];\n        }\n    }[\"FluidShader.useEffect\"], []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        className: \"fixed inset-0 w-full h-full block\"\n    }, void 0, false, {\n        fileName: \"/Users/nitishkumar/Desktop/verbose-pancake/src/components/fluid-shader.tsx\",\n        lineNumber: 114,\n        columnNumber: 5\n    }, this);\n}\n_s(FluidShader, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = FluidShader;\nclass Renderer {\n    updateShader(source) {\n        this.reset();\n        this.setupShader(source);\n        this.init();\n    }\n    updateScale(scale) {\n        this.scale = scale;\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n    }\n    compile(shader, source) {\n        this.gl.shaderSource(shader, source);\n        this.gl.compileShader(shader);\n        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\n            console.error(this.gl.getShaderInfoLog(shader));\n        }\n    }\n    test(source) {\n        const gl = this.gl;\n        const shader = gl.createShader(gl.FRAGMENT_SHADER);\n        if (!shader) return \"Could not create shader\";\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n        const log = gl.getShaderInfoLog(shader);\n        gl.deleteShader(shader);\n        return status ? null : log;\n    }\n    reset() {\n        const gl = this.gl;\n        if (this.program) {\n            gl.deleteProgram(this.program);\n            this.program = null;\n        }\n        if (this.buffer) {\n            gl.deleteBuffer(this.buffer);\n            this.buffer = null;\n        }\n    }\n    setupShader(fragmentSource) {\n        const gl = this.gl;\n        this.vs = gl.createShader(gl.VERTEX_SHADER);\n        this.fs = gl.createShader(gl.FRAGMENT_SHADER);\n        this.compile(this.vs, this.vertexSrc);\n        this.compile(this.fs, fragmentSource);\n        this.program = gl.createProgram();\n        gl.attachShader(this.program, this.vs);\n        gl.attachShader(this.program, this.fs);\n        gl.linkProgram(this.program);\n        if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {\n            console.error(gl.getProgramInfoLog(this.program));\n        }\n    }\n    setup() {\n        this.setupShader(this.vertexSrc);\n    }\n    init() {\n        const gl = this.gl;\n        if (!this.program) return;\n        this.buffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n            -1,\n            1,\n            -1,\n            -1,\n            1,\n            1,\n            1,\n            -1\n        ]), gl.STATIC_DRAW);\n        const position = gl.getAttribLocation(this.program, \"position\");\n        gl.enableVertexAttribArray(position);\n        gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);\n    }\n    render(now) {\n        const gl = this.gl;\n        if (!this.program) return;\n        gl.useProgram(this.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\n        const resolutionLocation = gl.getUniformLocation(this.program, \"resolution\");\n        const timeLocation = gl.getUniformLocation(this.program, \"time\");\n        gl.uniform2f(resolutionLocation, this.canvas.width, this.canvas.height);\n        gl.uniform1f(timeLocation, now * 0.001);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    }\n    constructor(canvas, scale){\n        this.vertexSrc = \"#version 300 es\\n  precision highp float;\\n  in vec4 position;\\n  void main() { gl_Position = position; }\";\n        this.program = null;\n        this.vs = null;\n        this.fs = null;\n        this.buffer = null;\n        this.canvas = canvas;\n        this.scale = scale;\n        const gl = canvas.getContext(\"webgl2\", {\n            powerPreference: \"low-power\",\n            antialias: false\n        });\n        if (!gl) throw new Error(\"WebGL2 not supported\");\n        this.gl = gl;\n        this.gl.getExtension('EXT_color_buffer_float');\n        this.gl.enable(this.gl.BLEND);\n        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n    }\n}\nvar _c;\n$RefreshReg$(_c, \"FluidShader\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2ZsdWlkLXNoYWRlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRXlDO0FBRXpDLE1BQU1FLGFBQWE7QUFDbkIsTUFBTUMsaUJBQWlCLE9BQU9EO0FBQzlCLE1BQU1FLFVBQVU7QUFDaEIsTUFBTUMsZUFBZTtBQUVyQixTQUFTQyxTQUFTQyxJQUFnQixFQUFFQyxJQUFZO0lBQzlDLElBQUlDLFVBQWlDO0lBQ3JDLE9BQU87UUFDTEEsV0FBV0MsYUFBYUQ7UUFDeEJBLFVBQVVFLFdBQVdKLE1BQU1DO0lBQzdCO0FBQ0Y7QUFFZSxTQUFTSTs7SUFDdEIsTUFBTUMsWUFBWVosNkNBQU1BLENBQW9CO0lBRTVDRCxnREFBU0E7aUNBQUM7WUFDUixNQUFNYyxTQUFTRCxVQUFVRSxPQUFPO1lBQ2hDLElBQUksQ0FBQ0QsUUFBUTtZQUViLElBQUlFLFdBQTRCO1lBQ2hDLE1BQU1DLE1BQU1DLEtBQUtDLEdBQUcsQ0FBQ2YsU0FBU2dCLE9BQU9DLGdCQUFnQixJQUFJaEI7WUFFekQsTUFBTWlCO2dEQUFTO29CQUNiLElBQUksQ0FBQ1IsUUFBUTtvQkFDYixNQUFNLEVBQUVTLFlBQVlDLEtBQUssRUFBRUMsYUFBYUMsTUFBTSxFQUFFLEdBQUdOO29CQUNuRE4sT0FBT1UsS0FBSyxHQUFHQSxRQUFRUDtvQkFDdkJILE9BQU9ZLE1BQU0sR0FBR0EsU0FBU1Q7b0JBQ3pCSCxPQUFPYSxLQUFLLENBQUNILEtBQUssR0FBRyxHQUFTLE9BQU5BLE9BQU07b0JBQzlCVixPQUFPYSxLQUFLLENBQUNELE1BQU0sR0FBRyxHQUFVLE9BQVBBLFFBQU87b0JBQ2hDVixxQkFBQUEsK0JBQUFBLFNBQVVZLFdBQVcsQ0FBQ1g7Z0JBQ3hCOztZQUVBLE1BQU1ZLGtCQUFrQnZCLFNBQVNnQixRQUFRO1lBQ3pDRixPQUFPVSxnQkFBZ0IsQ0FBQyxVQUFVRDtZQUVsQyxNQUFNRSx1QkFBd0I7WUEyQzlCZixXQUFXLElBQUlnQixT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RCxJQUFJLE1BQU0sSUFBSXNELE1BQU07UUFDekIsSUFBSSxDQUFDdEQsRUFBRSxHQUFHQTtRQUNWLElBQUksQ0FBQ0EsRUFBRSxDQUFDdUQsWUFBWSxDQUFDO1FBQ3JCLElBQUksQ0FBQ3ZELEVBQUUsQ0FBQ3dELE1BQU0sQ0FBQyxJQUFJLENBQUN4RCxFQUFFLENBQUN5RCxLQUFLO1FBQzVCLElBQUksQ0FBQ3pELEVBQUUsQ0FBQzBELFNBQVMsQ0FBQyxJQUFJLENBQUMxRCxFQUFFLENBQUMyRCxTQUFTLEVBQUUsSUFBSSxDQUFDM0QsRUFBRSxDQUFDNEQsbUJBQW1CO0lBQ2xFO0FBZ0dGIiwic291cmNlcyI6WyIvVXNlcnMvbml0aXNoa3VtYXIvRGVza3RvcC92ZXJib3NlLXBhbmNha2Uvc3JjL2NvbXBvbmVudHMvZmx1aWQtc2hhZGVyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIlxuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiXG5cbmNvbnN0IFRBUkdFVF9GUFMgPSAzMFxuY29uc3QgRlJBTUVfSU5URVJWQUwgPSAxMDAwIC8gVEFSR0VUX0ZQU1xuY29uc3QgTUFYX0RQUiA9IDEuNVxuY29uc3QgQ0FOVkFTX1NDQUxFID0gMC43NVxuXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jOiAoKSA9PiB2b2lkLCB3YWl0OiBudW1iZXIpIHtcbiAgbGV0IHRpbWVvdXQ6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGxcbiAgcmV0dXJuICgpID0+IHtcbiAgICB0aW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aW1lb3V0KVxuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmMsIHdhaXQpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmx1aWRTaGFkZXIoKSB7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50XG4gICAgaWYgKCFjYW52YXMpIHJldHVyblxuXG4gICAgbGV0IHJlbmRlcmVyOiBSZW5kZXJlciB8IG51bGwgPSBudWxsXG4gICAgY29uc3QgZHByID0gTWF0aC5taW4oTUFYX0RQUiwgd2luZG93LmRldmljZVBpeGVsUmF0aW8pICogQ0FOVkFTX1NDQUxFXG5cbiAgICBjb25zdCByZXNpemUgPSAoKSA9PiB7XG4gICAgICBpZiAoIWNhbnZhcykgcmV0dXJuXG4gICAgICBjb25zdCB7IGlubmVyV2lkdGg6IHdpZHRoLCBpbm5lckhlaWdodDogaGVpZ2h0IH0gPSB3aW5kb3dcbiAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoICogZHByXG4gICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogZHByXG4gICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGBcbiAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHR9cHhgXG4gICAgICByZW5kZXJlcj8udXBkYXRlU2NhbGUoZHByKVxuICAgIH1cblxuICAgIGNvbnN0IGRlYm91bmNlZFJlc2l6ZSA9IGRlYm91bmNlKHJlc2l6ZSwgMTAwKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGRlYm91bmNlZFJlc2l6ZSlcblxuICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyU291cmNlID0gYCN2ZXJzaW9uIDMwMCBlc1xuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgIG91dCB2ZWM0IE87XG4gICAgdW5pZm9ybSBmbG9hdCB0aW1lO1xuICAgIHVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xuICAgIFxuICAgIGZsb2F0IHJuZCh2ZWMyIHApIHtcbiAgICAgICAgcCA9IGZyYWN0KHAgKiB2ZWMyKDEyLjk4OTgsIDc4LjIzMykpO1xuICAgICAgICByZXR1cm4gZnJhY3QocC54ICogcC55ICogKHAueCArIHAueSkpO1xuICAgIH1cblxuICAgIGZsb2F0IG5vaXNlKHZlYzIgcCkge1xuICAgICAgICB2ZWMyIGkgPSBmbG9vcihwKSwgZiA9IGZyYWN0KHApO1xuICAgICAgICBmbG9hdCBhID0gcm5kKGkpLCBiID0gcm5kKGkgKyB2ZWMyKDEsMCkpO1xuICAgICAgICBmbG9hdCBjID0gcm5kKGkgKyB2ZWMyKDAsMSkpLCBkID0gcm5kKGkgKyB2ZWMyKDEsMSkpO1xuICAgICAgICB2ZWMyIHUgPSBmICogZiAqICgzLjAgLSAyLjAgKiBmKTtcbiAgICAgICAgcmV0dXJuIG1peChhLCBiLCB1LngpICsgKGMgLSBhKSogdS55ICogKDEuMCAtIHUueCkgKyAoZCAtIGIpICogdS54ICogdS55O1xuICAgIH1cblxuICAgIGZsb2F0IGZibSh2ZWMyIHApIHtcbiAgICAgICAgZmxvYXQgdCA9IDAuMCwgYSA9IDAuNTtcbiAgICAgICAgbWF0MiBtID0gbWF0MigwLjgsIDAuNiwgLTAuNiwgMC44KTtcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgIHQgKz0gYSAqIG5vaXNlKHApO1xuICAgICAgICAgICAgcCAqPSAyLjAgKiBtO1xuICAgICAgICAgICAgYSAqPSAwLjU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgKiAyLjA7XG4gICAgfVxuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2ZWMyIHV2ID0gKGdsX0ZyYWdDb29yZC54eSAqIDIuMCAtIHJlc29sdXRpb24pIC8gbWluKHJlc29sdXRpb24ueCwgcmVzb2x1dGlvbi55KTtcbiAgICAgICAgZmxvYXQgdCA9IHRpbWUgKiAwLjU7XG4gICAgICAgIFxuICAgICAgICBmbG9hdCBuID0gZmJtKHV2ICogMS41ICsgdmVjMih0ICogMC4zLCB0ICogMC4yKSk7XG4gICAgICAgIGZsb2F0IHIgPSBmYm0odXYgKiAyLjAgKyBuICsgdmVjMih0ICogMC4xLCB0ICogMC4zKSk7XG4gICAgICAgIGZsb2F0IGIgPSBmYm0odXYgKiAyLjUgLSBuICsgdmVjMih0ICogMC4yLCB0ICogMC40KSk7XG4gICAgICAgIFxuICAgICAgICB2ZWMzIGNvbCA9IHZlYzMociAqIDAuNSwgbiAqIDAuOCwgYiAqIDAuOSk7XG4gICAgICAgIGNvbCA9IGNsYW1wKGNvbCAqIDAuOCArIDAuMiwgMC4wLCAxLjApO1xuICAgICAgICBPID0gdmVjNChjb2wsIDEuMCk7XG4gICAgfWBcblxuICAgIHJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKGNhbnZhcywgZHByKVxuICAgIHJlbmRlcmVyLnNldHVwKClcbiAgICByZW5kZXJlci5pbml0KClcbiAgICByZXNpemUoKVxuXG4gICAgaWYgKHJlbmRlcmVyLnRlc3QoZnJhZ21lbnRTaGFkZXJTb3VyY2UpID09PSBudWxsKSB7XG4gICAgICByZW5kZXJlci51cGRhdGVTaGFkZXIoZnJhZ21lbnRTaGFkZXJTb3VyY2UpXG4gICAgfVxuXG4gICAgbGV0IGxhc3RSZW5kZXIgPSAwXG4gICAgbGV0IGFuaW1hdGlvbkZyYW1lSWQ6IG51bWJlclxuXG4gICAgY29uc3QgbG9vcCA9IChub3c6IG51bWJlcikgPT4ge1xuICAgICAgYW5pbWF0aW9uRnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKVxuICAgICAgY29uc3QgZGVsdGEgPSBub3cgLSBsYXN0UmVuZGVyXG4gICAgICBpZiAoZGVsdGEgPCBGUkFNRV9JTlRFUlZBTCkgcmV0dXJuXG4gICAgICBsYXN0UmVuZGVyID0gbm93XG4gICAgICByZW5kZXJlcj8ucmVuZGVyKG5vdylcbiAgICB9XG5cbiAgICBsb29wKDApXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgZGVib3VuY2VkUmVzaXplKVxuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWVJZClcbiAgICAgIHJlbmRlcmVyPy5yZXNldCgpXG4gICAgfVxuICB9LCBbXSlcblxuICByZXR1cm4gKFxuICAgIDxjYW52YXMgXG4gICAgICByZWY9e2NhbnZhc1JlZn0gXG4gICAgICBjbGFzc05hbWU9XCJmaXhlZCBpbnNldC0wIHctZnVsbCBoLWZ1bGwgYmxvY2tcIlxuICAgIC8+XG4gIClcbn1cblxuY2xhc3MgUmVuZGVyZXIge1xuICBwcml2YXRlIHZlcnRleFNyYyA9IGAjdmVyc2lvbiAzMDAgZXNcbiAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICBpbiB2ZWM0IHBvc2l0aW9uO1xuICB2b2lkIG1haW4oKSB7IGdsX1Bvc2l0aW9uID0gcG9zaXRpb247IH1gXG4gIFxuICBwcml2YXRlIGdsOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0XG4gIHByaXZhdGUgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudFxuICBwcml2YXRlIHNjYWxlOiBudW1iZXJcbiAgcHJpdmF0ZSBwcm9ncmFtOiBXZWJHTFByb2dyYW0gfCBudWxsID0gbnVsbFxuICBwcml2YXRlIHZzOiBXZWJHTFNoYWRlciB8IG51bGwgPSBudWxsXG4gIHByaXZhdGUgZnM6IFdlYkdMU2hhZGVyIHwgbnVsbCA9IG51bGxcbiAgcHJpdmF0ZSBidWZmZXI6IFdlYkdMQnVmZmVyIHwgbnVsbCA9IG51bGxcblxuICBjb25zdHJ1Y3RvcihjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCBzY2FsZTogbnVtYmVyKSB7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXNcbiAgICB0aGlzLnNjYWxlID0gc2NhbGVcbiAgICBjb25zdCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2wyXCIsIHsgXG4gICAgICBwb3dlclByZWZlcmVuY2U6IFwibG93LXBvd2VyXCIsXG4gICAgICBhbnRpYWxpYXM6IGZhbHNlXG4gICAgfSlcbiAgICBpZiAoIWdsKSB0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTDIgbm90IHN1cHBvcnRlZFwiKVxuICAgIHRoaXMuZ2wgPSBnbFxuICAgIHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0JylcbiAgICB0aGlzLmdsLmVuYWJsZSh0aGlzLmdsLkJMRU5EKVxuICAgIHRoaXMuZ2wuYmxlbmRGdW5jKHRoaXMuZ2wuU1JDX0FMUEhBLCB0aGlzLmdsLk9ORV9NSU5VU19TUkNfQUxQSEEpXG4gIH1cblxuICB1cGRhdGVTaGFkZXIoc291cmNlOiBzdHJpbmcpIHtcbiAgICB0aGlzLnJlc2V0KClcbiAgICB0aGlzLnNldHVwU2hhZGVyKHNvdXJjZSlcbiAgICB0aGlzLmluaXQoKVxuICB9XG5cbiAgdXBkYXRlU2NhbGUoc2NhbGU6IG51bWJlcikge1xuICAgIHRoaXMuc2NhbGUgPSBzY2FsZVxuICAgIHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodClcbiAgfVxuXG4gIHByaXZhdGUgY29tcGlsZShzaGFkZXI6IFdlYkdMU2hhZGVyLCBzb3VyY2U6IHN0cmluZykge1xuICAgIHRoaXMuZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKVxuICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpXG4gICAgaWYgKCF0aGlzLmdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIHRoaXMuZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKHRoaXMuZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKVxuICAgIH1cbiAgfVxuXG4gIHRlc3Qoc291cmNlOiBzdHJpbmcpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2xcbiAgICBjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKVxuICAgIGlmICghc2hhZGVyKSByZXR1cm4gXCJDb3VsZCBub3QgY3JlYXRlIHNoYWRlclwiXG5cbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpXG4gICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpXG4gICAgY29uc3Qgc3RhdHVzID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpXG4gICAgY29uc3QgbG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpXG4gICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcilcbiAgICByZXR1cm4gc3RhdHVzID8gbnVsbCA6IGxvZ1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsXG4gICAgaWYgKHRoaXMucHJvZ3JhbSkge1xuICAgICAgZ2wuZGVsZXRlUHJvZ3JhbSh0aGlzLnByb2dyYW0pXG4gICAgICB0aGlzLnByb2dyYW0gPSBudWxsXG4gICAgfVxuICAgIGlmICh0aGlzLmJ1ZmZlcikge1xuICAgICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMuYnVmZmVyKVxuICAgICAgdGhpcy5idWZmZXIgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cFNoYWRlcihmcmFnbWVudFNvdXJjZTogc3RyaW5nKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsXG4gICAgdGhpcy52cyA9IGdsLmNyZWF0ZVNoYWRlcihnbC5WRVJURVhfU0hBREVSKSFcbiAgICB0aGlzLmZzID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUikhXG5cbiAgICB0aGlzLmNvbXBpbGUodGhpcy52cywgdGhpcy52ZXJ0ZXhTcmMpXG4gICAgdGhpcy5jb21waWxlKHRoaXMuZnMsIGZyYWdtZW50U291cmNlKVxuXG4gICAgdGhpcy5wcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpIVxuICAgIGdsLmF0dGFjaFNoYWRlcih0aGlzLnByb2dyYW0sIHRoaXMudnMpXG4gICAgZ2wuYXR0YWNoU2hhZGVyKHRoaXMucHJvZ3JhbSwgdGhpcy5mcylcbiAgICBnbC5saW5rUHJvZ3JhbSh0aGlzLnByb2dyYW0pXG5cbiAgICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIodGhpcy5wcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZ2wuZ2V0UHJvZ3JhbUluZm9Mb2codGhpcy5wcm9ncmFtKSlcbiAgICB9XG4gIH1cblxuICBzZXR1cCgpIHtcbiAgICB0aGlzLnNldHVwU2hhZGVyKHRoaXMudmVydGV4U3JjKVxuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2xcbiAgICBpZiAoIXRoaXMucHJvZ3JhbSkgcmV0dXJuXG5cbiAgICB0aGlzLmJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKVxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KFstMSwgMSwgLTEsIC0xLCAxLCAxLCAxLCAtMV0pLCBnbC5TVEFUSUNfRFJBVylcblxuICAgIGNvbnN0IHBvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcInBvc2l0aW9uXCIpXG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb24pXG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKVxuICB9XG5cbiAgcmVuZGVyKG5vdzogbnVtYmVyKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsXG4gICAgaWYgKCF0aGlzLnByb2dyYW0pIHJldHVyblxuXG4gICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKVxuXG4gICAgY29uc3QgcmVzb2x1dGlvbkxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgXCJyZXNvbHV0aW9uXCIpXG4gICAgY29uc3QgdGltZUxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgXCJ0aW1lXCIpXG4gICAgXG4gICAgZ2wudW5pZm9ybTJmKHJlc29sdXRpb25Mb2NhdGlvbiwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodClcbiAgICBnbC51bmlmb3JtMWYodGltZUxvY2F0aW9uLCBub3cgKiAwLjAwMSlcblxuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpXG4gIH1cbn0iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwiVEFSR0VUX0ZQUyIsIkZSQU1FX0lOVEVSVkFMIiwiTUFYX0RQUiIsIkNBTlZBU19TQ0FMRSIsImRlYm91bmNlIiwiZnVuYyIsIndhaXQiLCJ0aW1lb3V0IiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsIkZsdWlkU2hhZGVyIiwiY2FudmFzUmVmIiwiY2FudmFzIiwiY3VycmVudCIsInJlbmRlcmVyIiwiZHByIiwiTWF0aCIsIm1pbiIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJyZXNpemUiLCJpbm5lcldpZHRoIiwid2lkdGgiLCJpbm5lckhlaWdodCIsImhlaWdodCIsInN0eWxlIiwidXBkYXRlU2NhbGUiLCJkZWJvdW5jZWRSZXNpemUiLCJhZGRFdmVudExpc3RlbmVyIiwiZnJhZ21lbnRTaGFkZXJTb3VyY2UiLCJSZW5kZXJlciIsInNldHVwIiwiaW5pdCIsInRlc3QiLCJ1cGRhdGVTaGFkZXIiLCJsYXN0UmVuZGVyIiwiYW5pbWF0aW9uRnJhbWVJZCIsImxvb3AiLCJub3ciLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJkZWx0YSIsInJlbmRlciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInJlc2V0IiwicmVmIiwiY2xhc3NOYW1lIiwic291cmNlIiwic2V0dXBTaGFkZXIiLCJzY2FsZSIsImdsIiwidmlld3BvcnQiLCJjb21waWxlIiwic2hhZGVyIiwic2hhZGVyU291cmNlIiwiY29tcGlsZVNoYWRlciIsImdldFNoYWRlclBhcmFtZXRlciIsIkNPTVBJTEVfU1RBVFVTIiwiY29uc29sZSIsImVycm9yIiwiZ2V0U2hhZGVySW5mb0xvZyIsImNyZWF0ZVNoYWRlciIsIkZSQUdNRU5UX1NIQURFUiIsInN0YXR1cyIsImxvZyIsImRlbGV0ZVNoYWRlciIsInByb2dyYW0iLCJkZWxldGVQcm9ncmFtIiwiYnVmZmVyIiwiZGVsZXRlQnVmZmVyIiwiZnJhZ21lbnRTb3VyY2UiLCJ2cyIsIlZFUlRFWF9TSEFERVIiLCJmcyIsInZlcnRleFNyYyIsImNyZWF0ZVByb2dyYW0iLCJhdHRhY2hTaGFkZXIiLCJsaW5rUHJvZ3JhbSIsImdldFByb2dyYW1QYXJhbWV0ZXIiLCJMSU5LX1NUQVRVUyIsImdldFByb2dyYW1JbmZvTG9nIiwiY3JlYXRlQnVmZmVyIiwiYmluZEJ1ZmZlciIsIkFSUkFZX0JVRkZFUiIsImJ1ZmZlckRhdGEiLCJGbG9hdDMyQXJyYXkiLCJTVEFUSUNfRFJBVyIsInBvc2l0aW9uIiwiZ2V0QXR0cmliTG9jYXRpb24iLCJlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSIsInZlcnRleEF0dHJpYlBvaW50ZXIiLCJGTE9BVCIsInVzZVByb2dyYW0iLCJyZXNvbHV0aW9uTG9jYXRpb24iLCJnZXRVbmlmb3JtTG9jYXRpb24iLCJ0aW1lTG9jYXRpb24iLCJ1bmlmb3JtMmYiLCJ1bmlmb3JtMWYiLCJkcmF3QXJyYXlzIiwiVFJJQU5HTEVfU1RSSVAiLCJjb25zdHJ1Y3RvciIsImdldENvbnRleHQiLCJwb3dlclByZWZlcmVuY2UiLCJhbnRpYWxpYXMiLCJFcnJvciIsImdldEV4dGVuc2lvbiIsImVuYWJsZSIsIkJMRU5EIiwiYmxlbmRGdW5jIiwiU1JDX0FMUEhBIiwiT05FX01JTlVTX1NSQ19BTFBIQSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/fluid-shader.tsx\n"));

/***/ })

});